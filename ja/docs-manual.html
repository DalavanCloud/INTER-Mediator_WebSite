<!DOCTYPE html>
<!--
/*
 * INTER-Mediator Ver.@@@@2@@@@ Released @@@@1@@@@
 *
 *   by Masayuki Nii  msyk@msyk.net Copyright (c) 2010-2014 Masayuki Nii, All rights reserved.
 *
 *   This project started at the end of 2009.
 *   INTER-Mediator is supplied under MIT License.
 */
-->
<html>
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link href="/pagestyle.css" rel="stylesheet" media="screen">
    <link rel="shortcut icon" href="/im-icon.png" type="image/png">
    <link rel="icon" href="/im-icon.png" type="image/png">
    <title>INTER-Mediator</title>
    <script type="text/javascript" language="JavaScript">
        var htmlDocumentModDate = document.lastModified;
    </script>
    <script type="text/javascript" language="JavaScript" src="/pagebuilder.js"></script>
    <script type="text/javascript" language="JavaScript" src="/files/jquery-1.10.2.min.js"></script>
</head>
<body>
<div id="navigationbox" class="graybox">
    <div id="navigation"></div>
    <div id="latestnews"></div>
</div>
<div id="page_header"></div>
<div id="page_contents">
<h2>INTER-MediatorによるWebアプリケーションの概要</h2>

<p>
    データベースにMySQLなど、PHPのPDOに対応したものを利用することを想定します。データベースが稼働しており、INTER-Mediatorがインストールされている状況であるとします。このとき、以下の2つのファイルを作成します。いずれのファイルについても原則はどこにあってもかまいませんが、定義ファイルはデータベースサーバと同一のコンピュータにあるようにするのが一般的でしょう。
</p>
<ul>
    <li>ブラウザにロードするHTMLファイル（「ページファイル」と名付けます）</li>
    <li>データベース接続など設定を記述したPHPファイル（「定義ファイル」と名付けます</li>
</ul>
<h3>定義ファイルの記述</h3>

<p>
    定義ファイルは、PHPのファイルにします。したがって、PHPの処理が可能なサーバに配置しないといけません。以下のように、INTER-Mediator.phpを読み込み、IM_Entry関数をコールします。この関数の引数の指定方法は、後で記述します。
</p>

<div class="code"><pre><code>&lt;?php
require_once ('INTER-Mediator/INTER-Mediator.php');
IM_Entry( $tableDefs, $optionDefs, $dbDefs, true );
?&gt;</code></pre>
</div>
<p>
    サンプルで言えば、sample_form_FMS_include.phpや、sample_form_MySQL_include.phpのファイルが、定義ファイルに相当します。定義ファイルに記述できる内容は<a href="docs-reference.html">こちら</a>のページにまとめてあります。
</p>

<h3>ページファイルの記述</h3>

<p>
    ページファイルでは、定義ファイルを、ヘッダエリアのscriptタグで読み込みます。定義ファイルは、JavaScriptのソースを返します。そして、典型的な方法として、ページを開いたときにデータベースのデータを取り出すという流れがあるかと思います。その場合、以下のように、bodyタグのonload属性に、NTERMediator.construct(true)というJavaScriptの呼び出しを記述します。基本的にはこれで、INTER-Mediatorが働き始めます。NTERMediator.construct(true)は、たとえばボタンをクリックして呼び出すという方法も取る事ができます。
</p>

<div class="code"><pre><code>&lt;html&gt;
    &lt;head&gt;
    &lt;script src="sample_form_MySQL_include.php"&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body onload="INTERMediator.construct(true)"&gt;
    :
    &lt;td&gt;&lt;input type="text" data-im="contact@datetime"/&gt;&lt;/td&gt;</code></pre>
</div>
<p>
    以上の準備をすれば、ページファイル内のタグのdata-im属性に記述を加えることで、そのタグの値や他の属性に対してデータベースから取り出したデータが設定されることになります。属性の値は「contact@datetime」といった記述を行います。この記述を「ターゲット指定」と呼ぶ事にします。また、ターゲット指定のあるタグのことを「リンクノード」と呼びます。ターゲット指定の詳細は、後で説明をします。
</p>

<p>
    サンプルで言えば、sample_form_FMS.htmlや、sample_form_MySQL.htmlのファイルが、ページファイルに相当します。
</p>

<h3>ページの表示</h3>

<p>  以上のような準備をした上で、ブラウザより、ページファイルにアクセスをします。そうすれば、リンクノードのターゲット指定や、定義ファイルでの指定に基づいて、データベースのデータを取り込んでページを構成します。データベースの内容を表示しますが、複数のレコードがあれば繰り返して一覧表示などを行います。</p>

<h2>INTER-MediatorによるWebページ生成</h2>

<p>
    INTER-Mediatorは、WebページのDOM構造をたどり、データベースとリンクするノード（以後「リンクノード」と記述）をさがします。そして、そのリンクノードの上位のノードをたどり、「エンクロージャ」と「リピータ」となるノードを探します。リピータ自身あるいはリピータに含まれるリンクノードをすべて集めてデータベースにアクセスします。そして、レコードの数だけリピータを繰り返して、データベースの内容をページに表示します。
</p>

<h3>リンクノードでのターゲット指定</h3>
<ul>
    <li>任意の要素をリンクノードにすることができます。</li>
    <li>data-im属性に「table@field@target」の記述で記載されいているものをリンクノードとみなします。現在はこの記述方法が推奨されます。</li>
    <li>複数の設定を行う場合、値には「table@field@target table@field@target...」のように空白で区切って記述します。</li>
</ul>

<p>
    class属性に「IM[table@field@target]」の記述で記載される場合、title属性に「table@field@target」で記載されるものも、過去との互換性のためにリンクノードとみなします。複数の設定があってもかまいません。class属性の場合は、「IM[table@field@target|table@field@target|...]」と記述します。title属性の場合は「table@field@target|table@field@target|...」と記述します。title属性、class属性はいずれもリンクノードの指定にできなくすることができます。INTER-Mediatorのconstructメソッドの最初にあるtitleAsLinLinfo、classAsLinkInfo変数にfalseを入れれば、それぞれの属性に記述されたリンク指定は無視します。</p>

<h3>ターゲット指定について</h3>

<p>
    「table@field@target」がひとまとまりのターゲット指定となります。
</p>
<ul>
    <li>tableはテーブル名を記述します。IM_Entry関数の第一引数に指定した配列のname属性の値を記述できます。</li>
    <li>
        fieldはフィールド名を指定します。IM_Entry関数の第一引数に指定した配列の中で、name属性に対応したテーブルアクセスの中にフィールドが含まれていれば、そのフィールドの値を利用して、リンクノードの値を変更あるいは設定します。
    </li>
    <li>targetはノードのどの属性にフィールド値を差し込むかを指定します。</li>
</ul>
<p>
    targetの指定は以下のようなルールになります。
</p>
<ul>
    <li>省略すると、ノードの値として設定します。</li>
    <li>「innerHTML」の場合は、ノードのinnerHTML属性にフィールドの値を設定します。</li>
    <li>「nodeText」の場合はテキストノードを作成して子ノードとして追加します。</li>
    <li>「style.STYLENAME」の場合は、STYLENAMEで指定したスタイルに値として追加します。たとえば、「style.backgroundColor」は背景色のスタイル属性に値を指定します。</li>
    <li>targetの最初の文字が「#」の場合、innerHTMLないしは属性を指定していれば、既存のノードのデータに追加します。</li>
    <li>targetの最初の文字が「$」の場合、既存のノードのデータに含まれる$の部分を、データベースのフィールドの値に置き換えます。</li>
</ul>
<h3>エンクロージャとリピータ</h3>

<p>
    エンクロージャとリピータとなり得るノードの組み合わせを以下の表に示します。
</p>

<div class="table">
    <table>
        <thead>
        <tr>
            <th>
                形態
            </th>
            <th>
                Enclosure
            </th>
            <th>
                Repeater
            </th>
            <th>
                Linked Element
            </th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <td>
                表
            </td>
            <td>
                TBODY
            </td>
            <td>
                TR
            </td>
            <td>
                any elements
            </td>
        </tr>
        <tr>
            <td>
                汎用
            </td>
            <td>
                DIV data-im-control="enclosure"
            </td>
            <td>
                DIV data-im-control="repeater"
            </td>
            <td>
                any elements
            </td>
        </tr>
        <tr>
            <td>
                汎用
            </td>
            <td>
                DIV class="_im_enclosure"
            </td>
            <td>
                DIV class="_im_repeater"
            </td>
            <td>
                any elements
            </td>
        </tr>
        <tr>
            <td>
                汎用
            </td>
            <td>
                SPAN data-im-control="enclosure"
            </td>
            <td>
                SPAN data-im-control="repeater"
            </td>
            <td>
                any elements
            </td>
        </tr>
        <tr>
            <td>
                汎用
            </td>
            <td>
                SPAN class="_im_enclosure"
            </td>
            <td>
                SPAN class="_im_repeater"
            </td>
            <td>
                any elements
            </td>
        </tr>
        <tr>
            <td>
                番号リスト
            </td>
            <td>
                OL
            </td>
            <td>
                LI
            </td>
            <td>
                LI itself or inside of LI elements
            </td>
        </tr>
        <tr>
            <td>
                箇条書き
            </td>
            <td>
                UL
            </td>
            <td>
                LI
            </td>
            <td>
                LI itself or inside of LI elements
            </td>
        </tr>
        <tr>
            <td>
                ポップアップ、リスト
            </td>
            <td>
                SELECT
            </td>
            <td>
                OPTION
            </td>
            <td>
                OPTION itself
            </td>
        </tr>
        </tbody>
    </table>
</div>
<p>テーブルの場合で説明します。たとえば、テーブルのあるセル、つまりTDタグで囲まれた中に、DIVタグ等で記述されたリンクノードがあったとします。そのリンクノードから上位のノードにたどって、TRをリピータとします。TRの1つ上位のノードはTBODYに必ずなります。そのTBODYがエンクロージャとなります。リンクノードに記述された情報からテーブルがわかり、そのテーブルへアクセスします。そして、レコードの値をリンクノードの定義に従って、ノードに反映されます。もし、レコードが複数あれば、リピータを複製して、その複製した一連のノードに対してリンクノードの処理を行います。ページファイルを作るときは、通常、TRタグによる要素が1つのテーブルを作りますが、レコードの数だけ行数が増えるということになります。なお、リピータとなるTRタグの要素は複数個あってもかまいません。レコードの数だけ複数のTRのセットが複製されて、データの反映が行われます。</p>

<h3>レコードがない場合の表示</h3>

<p>レコードがあれば、リピーターを複製していくつかのオブジェクトがページに見えますが、そのままだと、レコードがない場合、リピーターが全くない状態になってしまいます。そこで、リピーターの1つのdata-im-control属性を「noresult」にするか、あるいはclass属性を「_im_for_noresult_」とします。すると、このリピータはレコードが存在すれば単に消しさられますが、レコードがないときにはこのリピータが1つだけエンクロージャーの中に配置されます。「レコードがありません」などの記述をこの方法で組み込めます。</p>

<h3>エンクロージャやリピーターの動作をキャンセルする</h3>

<p>リンクノードを含むテーブルは、自動的に展開してしまいます。その展開をさせないようにするには、data-im-control属性の値を「ignore_enc_rep」とします。たとえば、1つのテーブルの中に複数のコンテキストからのフィールドを展開したい場合は、次のように記述して、TRをリピータとして認識しないようにします。</p>

<div class="code">
<pre><code>&lt;table&gt;
    &lt;tr data-im-control=&quot;ignore_enc_rep&quot;&gt;
        &lt;td&gt;
            &lt;span data-im-control=&quot;enclosure&quot;&gt;
            &lt;span data-im-control=&quot;repeater&quot;&gt;
                &lt;input data-im=&quot;context1@field1&quot; /&gt;
            &lt;/span&gt;
            &lt;/span&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr data-im-control=&quot;ignore_enc_rep&quot;&gt;
        &lt;td&gt;
            &lt;span data-im-control=&quot;enclosure&quot;&gt;
            &lt;span data-im-control=&quot;repeater&quot;&gt;
                &lt;input data-im=&quot;context2@field2&quot; /&gt;
            &lt;/span&gt;
            &lt;/span&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;</code></pre></div>


<h2>検索や並べ替えの動作と指定</h2>

<p>INTER-Mediatorは、検索に関して以下の3つの設定個所があります。あるいは、以下のような検索条件が付与されて、データベースの読み出しが行われます。</p>

<ol>
    <li>定義ファイルのコンテキストの中のqueryの設定</li>
    <li>INTERMediatorオブジェクトのadditionalConditionプロパティ（JavaScript）</li>
    <li>リレーションによって決まる外部キーと対応キーとの対応（定義ファイルのコンテキストの中のrelationの設定）</li>
</ol>

<p>定義ファイルのqueryでの設定は、「常に適用されたい検索条件」を与えるのに便利です。たとえば、あるフィールドの値が「3」のものだけをいつも選択するとか、消し込みのフィールドがあって消し込まれていないレコードだけをとってくるというような場合です。</p>
<p>一方、ユーザが入力した検索条件のようなデータは、INTERMediatorオブジェクトのadditionalConditionプロパティを使って指定ができます。テキストフィールドに入力したテキストやあるいは計算結果などを検索条件に与えたい場合は、この方法で指定をします。</p>
<p>そして、リレーションは、エンクロージャーとリピーターによる展開中に、さらに内包するエンクロージャーとリピーターが見つかったとき、内側のコンテキストのrelation設定を参照して、外側のレコードに対応した、つまり関連のあるレコードを取り出すための条件を与えます。</p>
<p>これら3つの条件は、無条件にANDで合成されます。</p>

<h3>コンテキストのqueryの指定方法</h3>
<p>定義ファイルのコンテキストのqueryは、キーとして、field、operator、valueを持つ配列を指定します。その指定を複数できるので、結果として、queryキーに対する値は配列の配列となります。</p>
<p>PDO対応のデータベースアクセスクラスを利用すると、単に「field operator 'value'」という形式での式が構築されます。値についてはquoteメソッドで処理をしてあります。従って、array( 'field'=&gt;'age',
    'operator'=&gt;'&gt;', 'value'=&gt;'19'
    )のような指定が一例です。文字列のワイルドカードを使う場合には、データベースエンジンに従った記述が必要です。たとえば、MySQLで前方一致させるには、array( 'field'=&gt;'name', 'operator'=&gt;'LIKE',
    'value'=&gt;'%田太郎' ) のような配列を指定します。operatorを省略すると、= とみなします。</p>


<p>'field' の値が '__operation__'
    の項目があれば、そこで区切りを入れます。そして区切りで分割したそれぞれについて、AND条件が適用された式が作られ、区切りで分割された固まりについてはOR演算となります。また、'field' の値が '__operation__'
    の項目の 'operator' が 'ex' なら、ORとANDを入れ替えます。言い換えれば、特に何もしなければ、AND条件で結びつけられますが、ANDやORを組み合わせた条件指定も可能ということです。'field' の値が
    '__operation__' の項目はいくつあってもかまいません。</p>


<div class="code">


   <pre><code>'query' =&gt; array(

       &nbsp;&nbsp;&nbsp;&nbsp;array( 'field'=&gt;'age', 'operator'=&gt;'&gt;', 'value'=&gt;'19' ),

       &nbsp;&nbsp;&nbsp;&nbsp;array( 'field'=&gt;'year', 'operator'=&gt;'&gt;', 'value'=&gt;'1980' ))


       生成される条件文：age &gt; '19' AND year &gt; '1980'</code></pre>


</div>


<div class="code">


   <pre><code>'query' =&gt; array(

       &nbsp;&nbsp;&nbsp;&nbsp;array( 'field'=&gt;'age', 'operator'=&gt;'&gt;', 'value'=&gt;'19' ),

       &nbsp;&nbsp;&nbsp;&nbsp;array( 'field'=&gt;'year', 'operator'=&gt;'&gt;', 'value'=&gt;'1980' ),

       &nbsp;&nbsp;&nbsp;&nbsp;array( 'field'=&gt;'__operation__' ),

       &nbsp;&nbsp;&nbsp;&nbsp;array( 'field'=&gt;'age', 'operator'=&gt;'&lt;', 'value'=&gt;'39' ),

       &nbsp;&nbsp;&nbsp;&nbsp;array( 'field'=&gt;'year', 'operator'=&gt;'&lt;', 'value'=&gt;'2006' ))


       生成される条件文：(age &gt; '19' AND year &gt; '1980') OR (age &lt; '39' AND year &lt; '2006')</code></pre>


</div>


<div class="code">


   <pre><code>'query' =&gt; array(

       &nbsp;&nbsp;&nbsp;&nbsp;array( 'field'=&gt;'age', 'operator'=&gt;'&gt;', 'value'=&gt;'19' ),

       &nbsp;&nbsp;&nbsp;&nbsp;array( 'field'=&gt;'year', 'operator'=&gt;'&gt;', 'value'=&gt;'1980' ),

       &nbsp;&nbsp;&nbsp;&nbsp;array( 'field'=&gt;'__operation__', 'operator'=>'ex' ),

       &nbsp;&nbsp;&nbsp;&nbsp;array( 'field'=&gt;'age', 'operator'=&gt;'&lt;', 'value'=&gt;'39' ),

       &nbsp;&nbsp;&nbsp;&nbsp;array( 'field'=&gt;'year', 'operator'=&gt;'&lt;', 'value'=&gt;'2006' ))


       生成される条件文：(age &gt; '19' OR year &gt; '1980') AND (age &lt; '39' OR year &lt; '2006')</code></pre>


</div>


<div class="code">


   <pre><code>'query' =&gt; array(

       &nbsp;&nbsp;&nbsp;&nbsp;array( 'field'=&gt;'age', 'operator'=&gt;'&gt;', 'value'=&gt;'19' ),

       &nbsp;&nbsp;&nbsp;&nbsp;array( 'field'=&gt;'year', 'operator'=&gt;'&gt;', 'value'=&gt;'1980' ),

       &nbsp;&nbsp;&nbsp;&nbsp;array( 'field'=&gt;'__operation__', 'operator'=>'ex' ))


       生成される条件文：age &gt; '19' OR year &gt; '1980'</code></pre>


</div>


<p>なお、ANDとORの組み合わせしかできないのかと思われるかもしれませんが、すべての論理式が論理和標準形ないしは論理積標準形で表現できるという定理があるので、この仕様ですべての論理式が記述できると言えるかと思われます。</p>


<p>FileMaker
    Serverの場合、FileMaker側の仕様の制限として、検索条件は全部ANDか全部ORかで結ぶしかできません。ANDとORを組み合わせることはできないのです。コンテキストのqueryキーの値、あるいはaddtionalConditionに「raray(
    'field'=&gt;'__operation__', 'operator'=>'or'
    )」を加えれば、OR演算を行います。この指定がなければAND演算になります。OR演算を指定した場合、外部キーの検索条件もORになってしまい、リレーションが正確にとれませんので、その点は十分に注意が必要です。</p>


<h3>INTERMediatorオブジェクトのadditionalConditionプロパティに指定する検索条件</h3>


<p>JavaScriptのプログラムで、INTERMediator.construct(true)
    を実行するよりも前に、例えば以下のようなプログラムを実行します。additionalConditionプロパティは配列で、最初のインデックスはコンテキスト名、つまり定義ファイルでの name
    キーに対応する値を指定します。右辺の条件は、もちろん、該当するコンテキストにしか適用されません。オブジェクトの値については前のqueryについての説明とおおむね共通です。OR条件とAND条件がどちらも出てくるような条件も記述できます。条件が一組の場合はオブジェクトとして記述できます。2つ以上あるときはオブジェクトの配列として記述します。</p>


<div class="code">


   <pre><code>INTERMediator.additionalCondition[コンテキスト名] = {field:'age', operator:'&gt;', value: 19}

       INTERMediator.additionalCondition[コンテキスト名] = [{field:'age', operator:'&gt;', value: 19}, {field:'year',
       operator:'&gt;', value: 1999}]</code></pre>


</div>


<h3>コンテキストのrelationキーの値</h3>


<p>
    こちらもqueryと同様、配列の配列という形式をとります。キーはqueryと違います。外側のエンクロージャー／リピータとその内側のエンクロージャー／リピーターがあるとします。外側はmaster、内側はdetailというコンテキスト名で定義されているとします。</p>


<div class="code">


   <pre><code>array(

       &nbsp;&nbsp;&nbsp;&nbsp;array( 'name' => 'master', 'key' => 'id' )),

       array(

       &nbsp;&nbsp;&nbsp;&nbsp;array(

       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'name' => 'detail',

       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'relation' => array( array( 'foreign-field' => 'master_id',
       'join-field' => 'id', 'operator' => '=' ))),</code></pre>


</div>


<p>
    外側のコンテキストの1レコードを処理すると、その内部にあるエンクロージャー／リピーターが見つかります。そのとき、コンテキスト名がdetailのrelationキーの値を参照します。そして、join-fieldキーについては、外側の1レコードに存在する値を取り出し、foreign-fieldキーの値とoperatorキーの値を使って検索条件を作ります。たとえば、外側のレコードのidフィールドの値が34だった場合、「master_id
    = '34'」という条件を作成し、AND条件として追加します。relationの配列は配列が複数あってもかまいません。その場合、すべての指定で生成される条件式のANDをとります。</p>


<p>なお、join-fieldの指定は必須です。不要と思われるかもしれませんが、必ずしも主キーとリンクしているとは限らないので指定は必須としました。</p>


<h3>検索結果の並べ替えに関して</h3>


<p>INTER-Mediatorは、検索結果の並べ替え関して以下の2つの設定個所があります。検索のクエリに対して、並べ替えの順序を決める基準となるフィールドを指定できます。</p>


<ol>


    <li>定義ファイルのコンテキストの中のsortの設定</li>


    <li>INTERMediatorオブジェクトのadditionalSortKeyプロパティ（JavaScript）</li>


</ol>


<p>
    定義ファイルのsortでの設定は、常に適用されるソートキーです。一方、additionalSortKeyプロパティはプログラムで状況に応じて設定されるソートキーです。検索時にはこれらが合成されて、並べ替えを行います。優先順位は、additionalSortKeyプロパティの方が上位になります。また、それぞれの設定の中で、指定した順序で上位の並べ替えフィールドとなります。いずれも、配列の形式で指定をし、fieldとdirectionというキーを指定します。fieldキーに対する値は1つのフィールド名を指定します。directionに対する値はデータベースエンジンに従います。たとえば、MySQLだと、ASCあるいはDESCを指定しますが、FileMaker
    Serverはascendあるいはdescendを指定します。additionalSortKeyプロパティについては、addtionalConditionプロパティと同様、最初のインデックスはコンテキスト名を指定し、その後にオブジェクトあるいはオブジェクトの配列を指定します。</p>

<h2>ページ移動ナビゲーションの構築</h2>

<p>
    ページ移動のナビゲーションは、ページの中に、idが「IM_NAVIGATOR」のノードがあれば、そのノードの内容を置き換えてナビゲーションを作成します。「IM_NAVIGATOR」のidのノードがない場合には、ナビゲーションは表示されません。通常は、divタグの要素を「&lt;div
    id="IM_NAVIGATOR"&gt;&lt;/div&gt;」のように作っておくのがいいでしょう。</p>

<p>
    INTER-Mediator.constructメソッドは、ノードを見つけて自動的にページナビゲーションにしますが、それらの要素に以下のようなクラス設定をしています。つまり、ページで、これらのクラスに対してスタイルシートで定義を行えば、見栄えについては自由に設定ができます。</p>

<div class="table">
    <table>
        <tr>
            <th>要素名.クラス名</th>
            <th>設定先</th>
        </tr>
        <tr>
            <td>.IM_NAV_panel</td>
            <td>ナビゲーションそのもの。つまり、idが「IM_NAVIGATOR」のノードに設定される</td>
        </tr>
        <tr>
            <td>span.IM_NAV_info</td>
            <td>文字情報を表示する部分に設定される</td>
        </tr>
        <tr>
            <td>span.IM_NAV_button</td>
            <td>クリックできるボタンに対して設定される</td>
        </tr>
        <tr>
            <td>span.IM_NAV_disabled</td>
            <td>クリックできないボタンに対して設定される</td>
        </tr>
    </table>
</div>

<p>
    ナビゲーション領域の文言等は、INTERMediator.navigationLabelに配列を設定することで、任意に設定できます。配列のインデックスと対応する箇所は以下の表に示します。INTERMediator.navigationLabelに何も設定しない場合には、表の既定値が画面に見えます。</p>

<div class="table">
    <table>
        <tr>
            <th>インデックス</th>
            <th>設定対象</th>
            <th>既定値</th>
            <th>非表示</th>
        </tr>
        <tr>
            <td>0</td>
            <td>最初のレコードに戻る</td>
            <td>&lt;&lt;</td>
            <td>インデックス0〜3</td>
        </tr>
        <tr>
            <td>1</td>
            <td>前のページに戻る</td>
            <td>&lt;</td>
            <td>無関係</td>
        </tr>
        <tr>
            <td>2</td>
            <td>次のページに進む</td>
            <td>&gt;</td>
            <td>無関係</td>
        </tr>
        <tr>
            <td>3</td>
            <td>最後のレコードに進む</td>
            <td>&gt;&gt;</td>
            <td>無関係</td>
        </tr>
        <tr>
            <td>4</td>
            <td>レコード番号の直前</td>
            <td>レコード番号</td>
            <td>インデックス4〜7</td>
        </tr>
        <tr>
            <td>5</td>
            <td>レコード番号の範囲の間の文字列</td>
            <td>-</td>
            <td>無関係</td>
        </tr>
        <tr>
            <td>6</td>
            <td>レコード番号範囲と全レコード数の間の文字列</td>
            <td>/</td>
            <td>無関係</td>
        </tr>
        <tr>
            <td>7</td>
            <td>全レコード数の後の文字列</td>
            <td>（空文字列）</td>
            <td>無関係</td>
        </tr>
        <tr>
            <td>8</td>
            <td>更新ボタンの名称</td>
            <td>更新</td>
            <td>インデックス8</td>
        </tr>
    </table>
</div>
<p>
    INTERMediator.navigationLabelに指定する配列は9つの要素を指定します。それぞれ、インデックスに要素が対応します。要素がnullだと既定値のままになります。文字列を指定すると、その文字列に置き換わります。インデックスが0、4,、8の要素に関しては、「非表示」の列に示したインデックスのものが非表示になります。たとえば、以下の記述だと、Refreshボタンのみが消えて他は既定とおりのものが表示されます。</p>

<p>INTERMediator.navigationLabel = [null, null, null, null, null, null, null, null, false];</p>

<h2>HTMLのUIコンポーネントの扱い</h2>

<h3>テキストフィールド</h3>

<p>
    INPUTタグ要素のtype属性がtextの場合、ターゲット指定の3つ目の指定は省略できます。その場合、value属性に値が設定されます。また、onchange属性にINTERMediator.changeValue(*)の呼び出しプログラムが登録されるので、テキストを編集し、フォーカスを別のフィールドに移動したときなどに、テキストフィールドの内容がデータベースに書き戻されます。</p>

<h3>テキストエリア</h3>

<p>ターゲット指定の3つ目の指定は省略できます。すると、TEXTAREAタグ要素のテキストとして設定されます。</p>

<h3>ポップアップメニュー／リスト</h3>

<p>
    SELECTタグの要素自体が値を持つコンポーネントです。SELECTタグ要素のターゲット指定の3つ目の項目を省略すると、SELECT要素の選択値として指定されます。また、OPTIONタグは決められたものでもかまいませんが、データベースからも値を設定できます。このとき、自動的に、SELECT/OPTIONタグがエンクロージャー／リピータとなります。OPTIONタグはSELECTタグ要素の選択値に対応するvalue属性と、実際にメニュー項目として見えるOPTIONタグ要素のテキストの2つの設定が必要になるでしょう。従って、「&lt;option
    data-im="contact_way@id@value contact_way@name"&gt;&lt;/option&gt;」のようなターゲット指定が2つありょうなタグ要素をSELECTの中に1つだけ作っておき、ターゲット指定の1つ目の名前のコンテキスト定義を定義ファイルに記述しておきます。</p>

<h3>チェックボックス</h3>

<p>
    データベースから読み出された特定のフィールドのデータがチェックボックスのINPUTタグ要素とリンクされている場合、そのタグのvalue属性を調べます。そして、データとvalue属性が一致していればチェックを入れます。データの有無ではなく、valueとの一致を調べます。また、書き戻す場合は、チェックが入ったときはvalue属性の値、チェックがなくなった場合には空文字列を書き戻します。通常、数値フィールドで、1ならチェックあり、それ以外ならチェックなしといったデータの持たせ方をするのが順当でしょう。</p>

<h3>ラジオボタン</h3>

<p>
    ラジオボタンに展開したい場合、同一のターゲット指定のINPUTタグでtype属性が「radio」のものを並べます。すると、name属性を自動的に設定し、複数レコードが繰り返されたときでも、問題なく処理できるようになります。それぞれのINPUTタグ要素のvalue属性はおのおのが自分の値を持ちます。データベースのフィールドの値とvalue属性の値を比べて同一のものが選択されます。</p>

<h3>隠しフィールド</h3>

<p>
    INPUTタグ要素のtype属性が「hidden」のものがよく利用されますが、むしろ、divやspanを使っていちばん外側の要素のdisplayスタイルをnoneにしておくという手段が使えます。たとえば、マスターの値を見えないタグ要素としてページ上に展開し、JavaScriptでそれらを得るという手も使えます。</p>

<h2>入力フォーム型ページの作成</h2>

<p>アンケートの回答のような、入力フォームがあってその内容に従った新規レコードを作るだけのようなページの作り方をここで説明します。そのようなページを作るのに必要なことは以下の通りです。</p>
<ul>
    <li>HTMLでフォームを作るが、FORMタグは不要。必要なテキストフィールドと、登録ボタンを作成する。ただし、テキストフィールドなどは、1つのエンクロージャにまとめておく。</li>
    <li>定義ファイルに、レコードの作成が可能なコンテキストを定義する。</li>
    <li>入力フォームにしたいエンクロージャのdata-im-control属性を「post」とする。</li>
    <li>HTMLのフォームの入力要素をリンクノードにします。つまり、コンテキストの名前（context）と対応するテーブルのフィールド名（field）に対して、data-im="context@field"
        をタグの中に記述する。
    </li>
    <li>「登録」ボタンはBUTTONタグで作成し、data-im-control属性に「post」を指定する。ボタン名は任意。</li>
</ul>
<p>登録ボタンを押した後の動作については、コンテキストに定義できる「post-」で始まる3つの項目が用意されています。ボタンを何度も押す事を避けるために、ボタンをメッセージで置き換えたり、別のページに移動したり、ページの再描画ができます。</p>

<p>コンテキストに指定したバリデーションの設定についても設定されますが、編集時と異なり、登録ボタンを押したときに、入力項目に対してまとめて判定が行われて、ページ内にエラーを表示したり、ダイアログボックスを表示したりができます。</p>

<p>この機能を使う場合、data-im-control属性に「post」を指定したエンクロージャーの外部にあるエンクロージャーに対しては、普通にページ合成ができるので、データベースアクセスの結果と、入力フォームを混在させることもできます。また、入力フォームの内部のエンクロージャーも同様に通常通り処理されるので、マスターの内容からポップアップを構築する事ができます。</p>

<p>登録ボタンをクリックした後に独自のプログラムを追加したい場合は、以下のような記述の関数を定義します。メッセージ表示、ページ再合成、ページ移動が定義されていた場合、それらよりも前に、以下に定義した関数を実行します。processingBeforePostOnlyContextは、データベースへの書き込み前に実施され、返り値がfalseだとデータベース処理を行わず、ページ移動なども行いません。processingAfterPostOnlyContextはデータベース処理後に実行され、返り値は指定しません。</p>

<div class="code"><pre><code>INTERMediatorOnPage.processingBeforePostOnlyContext = function(node){
    // any program here.
};
INTERMediatorOnPage.processingAfterPostOnlyContext = function(node){
    // any program here.
};</code></pre>
</div>

<h2>ブラウザのバージョンを調べる仕組み</h2>
<p>ブラウザのバージョンを調べて、一定のもの以外は表示できないようにしたいと思うこともあります。この機能を、必要に応じて利用できるようにしました。</p>
<p>まず、INTER-Mediator.phpと同じディレクトリにある$paramsファイルに、変数名$browserCompatibilityという変数を定義し、配列記述します。配列の記述方法は表に示します。作成例も紹介します。。</p>

<div class="table">
    <table>
        <tr>
            <th>次元</th>
            <th>指定内容</th>
            <th>指定する値の例</th>
        </tr>
        <tr>
            <td>第1次元</td>
            <td>ブラウザの種類</td>
            <td>msie, firefox, safari, chrome, opera</td>
        </tr>
        <tr>
            <td>第2次元</td>
            <td>配列（OSを示すキー）</td>
            <td>mac, win</td>
        </tr>
        <tr>
            <td></td>
            <td>バージョン記述文字列</td>
            <td>3+, 4-</td>
        </tr>
        <tr>
            <td>第3次元</td>
            <td>バージョン記述文字列（第2次元が配列のとき）</td>
            <td>3+, 4-</td>
        </tr>
    </table>
</div>

<div class="code"><pre><code>$browserCompatibility = array(
    'msie' => '7+',
    'firefox' => '2+',
    'safari' => array( 'win' => '4+', 'mac' => '3+' ),
    'chrome' => '1+',
    'opera' => '1+',
);</code></pre></div>

<p>「バージョン記述文字列」は、数字とプラスないしはマイナスで指定します。「3+」は3以上、「3-」は3以下のバージョンで利用できることを示します。プラスあるいはマイナスを付けないと、その数値のバージョンのみです。ブラウザ名やOSは、大文字小文字は関係ありません。</p>
<p>前の例だと、Safariのみ、OSごとに分岐しています。WindowsならVer.4以上、MacならVer.3以上は利用可能であることを示しています。</p>

<h3>ブラウザの互換性をメッセージとして表示する</h3>
<p>JavaScriptベースで動くINTER-Mediatorにとって、これがいちばん難しい仕事かもしれません。ブラウザによっては、JavaScriptが動かないこともあるかもしれないのです。こうした状況をうまく処理するために、以下のような点を考慮します。</p>
<ol>
    <li>ページファイルの中の、bodyタグ要素の直下あたりに、INTER-Mediatorが一切しない場合のメッセージを付けておく。たとえば、サンプルファイルの「WebSite」のindex.htmlにあるid=nonsupportedmessageのdivタグ要素。INTER-Mediatorの動作が成功すれば、このノードを削除するか表示しないようにする。これにより、JavaScriptが一切動かない状態でも、何らかのメッセージが見えるようになる。</li>
    <li>ページファイルの構築を以下のようなプログラムにする。INTERMediatorCheckBrowser関数で前に説明した$paramsファイルの変数の定義に従って、ブラウザの互換性をチェックする。もし、対応でないならfalseを返すので、ページ構築はしない。また、その場合は、body要素の中身をいちど全部クリアして、メッセージだけを表示する。もし、対応しているならnodeで示したノードを削除する。nodeはnullあるいは未指定でも構わない。</li>
</ol>
<p>上記の2つのうち、一方だけでもかまいませんし、両方をやってもかまいません。また、チェックは不要ということなら、単にINTERMediator.construct(true);を呼び出すだけでもいいでしょう。</p>

<div class="code"><pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=UTF-8&quot;/&gt;
    &lt;title&gt;Page Title&lt;/title&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;context.php&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        window.onload = function () {
            var nonSupportNode = document.getElementById('nonsupportmessage');
            if (INTERMediatorOnPage.INTERMediatorCheckBrowser(nonSupportNode)) {
                INTERMediator.construct(true);
            }
        }
        INTERMediatorOnPage.doAfterConstruct = function () {
            var contentNode = document.getElementById('container');
            contentNode.style.display = &quot;block&quot;
        }
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;nonsupportmessage&quot; style=&quot;background-color:#333333&quot;&gt;
        &lt;div style=&quot;text-align:center;color:yellow&quot;&gt;If you see this, you must use any unsupported web browser. Or constructing the page.
        &lt;/div&gt;
        &lt;div style=&quot;text-align:center;color:yellow&quot;&gt;この表示が見えている場合、描画処理中です。しばらくお待ちください。長時間見えている場合は、非対応ブラウザで参照しています。&lt;/div&gt;
    &lt;/div&gt;
    &lt;div id=&quot;container&quot; style=&quot;display: none&quot;&gt;
        // ページコンテンツ
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre></div>

<h2>データコンバータクラスの利用方法</h2>

<p>
    IM_Entry関数の第2引数で、'formatter'を利用して、特定のコンテキストのフィールドに対して、データベースの読み書き前後にフィルタを設定することができます。このときに使うクラスをデータコンバータクラスと呼びます。自分で作成もできますが、以下のものが最初から組み込まれています。自分で作成する場合はDataConverter_template.phpを参照してください</p>

<div class="table">
    <table>
        <tr>
            <td>DataConverter_AppendPrefix.php</td>
            <td>parameterに指定した文字列を前につける</td>
        </tr>
        <tr>
            <td>DataConverter_AppendSuffix.php</td>
            <td>parameterに指定した文字列を後につける</td>
        </tr>
        <tr>
            <td>DataConverter_Currency.php</td>
            <td>parameterに指定した小数以下の桁数で、数値を通貨で表示する</td>
        </tr>
        <tr>
            <td>DataConverter_FMDateTime.php</td>
            <td>FileMaker Serverの出力する「月/日/年」形式の日付や時刻を整える</td>
        </tr>
        <tr>
            <td>DataConverter_HTMLString.php</td>
            <td>改行をBRタグ要素、そして&lt;や&gt;や&amp;を参照形式に変換する。parameterにautolinkと指定するとURLにAタグ要素を付加してリンクに変換する。バージョン4.2以降においてparameterにnoescapeと指定すると参照形式への変換を無効にする。データベースへの書き込み時はそのままの文字列</td>
        </tr>
        <tr>
            <td>DataConverter_MySQLDateTime.php</td>
            <td>MySQLの出力する「年-月-日」形式の日付や時刻を整える</td>
        </tr>
        <tr>
            <td>DataConverter_Number.php</td>
            <td>parameterに指定した小数以下の桁数で、数値をカンマ付きで表示する</td>
        </tr>
        <tr>
            <td>DataConverter_NumberBase.php</td>
            <td>NumberやCurrencyの基底クラス</td>
        </tr>
        <tr>
            <td>DataConverter_NullZeroString.php</td>
            <td>書き込み時にデータが''ならNULLとする、読み込み時は逆変換</td>
        </tr>
        <tr>
            <td>DataConverter_template.php</td>
            <td>データコンバータのクラスのテンプレート</td>
        </tr>
    </table>
</div>
<h2>データベースクラスを自作する</h2>

<p>
    データベースクラスを独自に作成する場合には、以下のようなPHPのクラスが基本となります。もちろん、データベースクラスを1から作れるのですが、たぶん、そういうニーズはまずないと思います。データベースをPDOで使うならINTER-MediatorのDB_PDO.php、FileMaer
    Serverを使うならDB_FileMaker_FX.phpを拡張したクラスを定義します。基底クラスの方のファイルも読み込みが必要です。以下の例は、INTER-Mediatorフォルダと同じフォルダに、このデータベースクラスのファイルがあるというわけです。自分が作るクラスでも、最初にDBをつけないといけません。IM_Entry関数の引数などでの設定は、この場合DB_をのぞいた「MyOriginalDB」を指定します。</p>


<div class="code">


   <pre><code>require_once( "INTER-Mediator/DB_PDO.php" );


       class DB_MyOriginalDB extends DB_PDO.php {


       function getFromDB($dataSourceName) {

       /*
       ここにプログラムを追加できる
       */

       $result = super::getFromDB($dataSourceName);

       /*
       ここにプログラムを追加できる
       */

       $this->mainTableCount = count( $result ); //レコード数

       return $result;
       }

       function setToDB($dataSourceName) {

       /*
       ここにプログラムを追加できる
       */

       super::setToDB($dataSourceName);

       /*
       ここにプログラムを追加できる
       */

       }

       function newToDB($dataSourceName) {

       /*
       ここにプログラムを追加できる
       */

       $lastKeyValue = super::newToDB($dataSourceName);

       /*
       ここにプログラムを追加できる
       */

       return $lastKeyValue;

       }

       function deleteFromDB($dataSourceName) {

       /*
       ここにプログラムを追加できる
       */

       $result = super::deleteFromDB($dataSourceName)
       ;
       /*
       ここにプログラムを追加できる
       */

       }

       }</code></pre>


</div>


<p>
    自分で作るクラスでは、要はCRUDに対応した4つのメソッドをオーバーライドすることによって、独自の仕組みを組み込むことができます。また、4つのうち、特にプログラムの追加がない場合には、定義する必要はありません。いずれの関数も、コンテキスト名を引数に取ります。そして、現在処理しているコンテキスト名が設定されてこれらのメソッドを呼び出します。</p>


<p>
    getFromDBメソッドは、データベースからデータを取り出します。取り出し結果は連想配列の配列です。連想配列のキーがフィールド名になっています。そこから、特定のフィールドの値を元に集計をしたり、あるいは必要な値だけに取り除くなどの処理を、親クラスのgetFromDBメソッドを呼び出す後に入れればいいでしょう。リクエスト時と同じフィールド名を返す必要はなく（つまりINTER-Mediatorはそのチェックをしていない）、自由に連想配列の配列を作ります。そして、ページファイルの方で適切なフィールド名を指定すれば、集計結果が表示されます。なお、ページファイルで、一定レコード数ごとのページングをしているときには、mainTableCountメンバ変数にレコード数、つまり返す配列の要素数も指定します。何か問題が発生したのなら、array()
    を返します。以下のプログラムは売り上げのテーブルから集計を行う例です。</p>


<div class="code">


   <pre><code>$result = super::getFromDB($dataSourceName);

       if ( $dataSourceName == 'ItemsInvoice' ) {

       $summary = array();

       foreach( $returnValue as $record ) {

       $summary[ $record[ 'itemNo' ]] += $record[ 'qty' ] * $record[ 'unitPrice' ];

       }

       return array( $summary );

       }</code></pre>


</div>


<p>
    getFromDBメソッドを呼び出す前は、検索条件の追加なども可能です。たとえば、IM_Entry関数の第一引数に指定している配列が、$this->dataSourceで得られます。また、現在のコンテキストが$this->dataSourceで得られる配列の何番目かが$this->getIndexOfDataSource($dataSourceName)で得られます。例えば特定の名前のフィールドがあれば、それをFileMaker
    Serverのグローバルフィールドに設定して、検索条件から取り除くといったことも行えます。</p>


<div class="code">


    <pre><code>$this->dataSource[ $this->getIndexOfDataSource($dataSourceName) ][ 'global' ] = array( ...
        );</code></pre>


</div>


<p>setToDBとdeleteFromDBメソッドは、いずれも値の更新や削除のときに呼び出されるメソッドです。返り値は論理値で、処理が成功すればtrueで失敗ならfalseです。</p>


<p>newToDBは新規レコードの作成です。メソッドの返り値は、新たに作ったレコードのキーフィールドの値である必要があります。問題があれば返り値をfalseにします。</p>


<h3>データベースクラス内で便利なメソッド</h3>


<p>現状、未整理です。DB_Base.phpに多くは定義されています。以下は抜粋です。</p>


<div class="table">


    <table>


        <tr>
            <th>メンバ変数／メソッド</th>
            <th>役割</th>
        </tr>


        <tr>
            <td>$this->dataSource</td>
            <td>IM_Entry関数の第1引数の配列</td>
        </tr>


        <tr>
            <td>$this->currentUser</td>
            <td>ログインしたユーザ名</td>
        </tr>


        <tr>
            <td>$this->setDebugMessage($str)</td>
            <td>デバッグメッセージに追加する</td>
        </tr>


        <tr>
            <td>$this->setErrorMessage($str)</td>
            <td>エラーメッセージに追加する</td>
        </tr>


        <tr>
            <td>$this->setExtraCriteria($field, $operator, $value)</td>
            <td>検索条件の追加</td>
        </tr>


        <tr>
            <td>$this->setExtraSortKey($field, $direction)</td>
            <td>ソート条件の追加</td>
        </tr>


    </table>


</div>
<h2>データベースアクセス処理の拡張クラスを定義する</h2>

<p>
    データベース側の処理に割り込むには「データベースクラスを自作する」で説明する手法（「データアクセスクラスのサブクラスを利用する方法」と定義します）とここで説明する手法（「拡張処理クラスを定義する方法」とします）の2通りがあります。「データアクセスクラスのサブクラスを利用する方法」だと、すべてのコンテキストに対する処理を記述しなければなりません。言い換えれば、複数あるコンテキストの１つだけに対して処理を加えたい場合、そのコンテキストのときだけプログラムが実行されるようにする必要があります。コンテキストが増減したときのメンテナンスタスクが増えます。「拡張処理クラスを定義する方法」だと、特定のコンテキストにだけ利用されるクラスを指定するので、「コンテキストごとに分岐させる」処理は不要です。</p>

<p>
    IM_Entry関数の第一引数、つまりコンテキストの中に「extending-class」でクラス名を指定します。ここで指定したクラス名は任意のものでかまいませんが、そのクラスをPHPが認識できる場所に記述しておく必要があります。クラスは以下のようなインタフェースをインプリメントする必要があります。つまり、CRUDに対応する4種類のデータアクセス処理の前後にメソッドを含めることができるのです。</p>

<div class="code">
<pre><code>interface Extending_Interface_BeforeGet {
    function doBeforeGetFromDB($dataSourceName);
    }
    interface Extending_Interface_AfterGet {
    function doAfterGetFromDB($dataSourceName, $result);
    // function countQueryResult($dataSourceName);
    }
    interface Extending_Interface_BeforeSet {
    function doBeforeSetToDB($dataSourceName);
    }
    interface Extending_Interface_AfterSet {
    function doAfterSetToDB($dataSourceName, $result);
    }
    interface Extending_Interface_BeforeNew {
    function doBeforeNewToDB($dataSourceName);
    }
    interface Extending_Interface_AfterNew {
    function doAfterNewToDB($dataSourceName, $result);
    }
    interface Extending_Interface_BeforeDelete {
    function doBeforeDeleteFromDB($dataSourceName);
    }
    interface Extending_Interface_AfterDelete {
    function doAfterDeleteFromDB($dataSourceName, $result);
    }</code></pre>
</div>

<p>
    以下は、データベースからレコードを取得した後に呼び出されるクラスの定義例です。MyProgramというクラス名は任意ですが、2つのメソッドはインタフェースに決められたものを定義します。doAfterGetFromDBはデータベースからデータを取得した後に呼び出されます。引数$resultにはデータベースからの取得した結果が、連想配列の配列の形式で入っています。1レコードがフィールド名をキーとした連想配列になっており、レコードの数だけその配列があります。たとえば集計処理などを行い、同様に連想配列の配列にして結果を返します。このとき、ナビゲーションを使ってページ送りの処理をしているのなら、「レコードの個数」をcountQueryResultメソッドで返す必要があります。ナビゲーションがない場合にはこのメソッドの実装は不要です。また、ナビゲーションを使う場合でも、レコード総数がdoAfterGetFromDBの処理の後でも変わらないのであれば、countQueryResultメソッドは不要です。PHPではoptionのメソッドの定義をインタフェースできないので、定義上はコメントでこのメソッドを記載しています。</p>

<div class="code">
<pre><code>class MyProgram implements Extending_Interface_AfterGet
    {
    function doAfterGetFromDB($dataSourceName, $result) {
    foreach( $result as $record ) {
    foreach( $record as $field =&gt; $value ) {
    :
    }
    }
    $return result;
    }
    }</code></pre>
</div>

<p>
    countQueryResultメソッドを記述する場合の例を以下に示します。countQueryResultはdoAfterGetFromDBよりも後に呼び出されます。countQueryResultによって返されるのは、実際のレコード数ではなく、検索条件に合ったレコード数です。つまり、1万個のレコードのうち40個を表示している場合には、1万という数値を返す必要があります。doAfterGetFromDBで集計処理などをすると、1万レコードを取得して、それが20個などになると思います。その場合は20個を返さないといけません。この場合、自分でメンバ変数（dataCount）を定義して、そこに値を残しておくのが分かりやすい方法でしょう。</p>

<div class="code">
<pre><code>class MyProgram implements Extending_Interface_AfterGet
    {
    var $dataCount;
    function doAfterGetFromDB($dataSourceName, $result) {
    :
    $thisthis-&gt;dataCount = count( $result );
    $return result;
    }
    function countQueryResult($dataSourceName) {
    $return $thisthis-&gt;dataCount;
    }
    }</code></pre>
</div>

<p>
    それぞれのメソッドの$dataSourceNameはコンテキスト名の文字列が入っています。2つのコンテキストでクラスを共有するような場合には分岐のための手がかりになります。doAfterNewToDBの2つ目の引数$resultは、新たに作成したレコードのキーフィールドの値が設定されています。この値はdoAfterNewToDBメソッドでの返り値にしなければなりません。doAfterDeleteFromDBとdoAfterSetToDBメソッドの2つ目の引数はデータベース処理が失敗したかどうかをbooleanで示され、trueなら処理が成功です。これらのメソッドでもやはり引数で得られた値を返さないといけません。</p>

<p>開発者が作成するクラスで「DB_UseSharedObjects」クラスの子クラスにした場合は、他のオブジェクトへの参照が得られます。メソッドが呼び出された段階で、メンバ変数はオブジェクトを参照した状態になります。</p>


<div class="table">
    <div class="caption">DB_UseSharedObjectsを継承したときに利用できるメンバ変数</div>
    <table>
        <tr>
            <th>メンバ変数</th>
            <th>参照するもの</th>
        </tr>
        <tr>
            <td>$this-&gt;dbSettings</td>
            <td>DB_Settingsクラスのインスタンス</td>
        </tr>
        <tr>
            <td>$this-&gt;logger</td>
            <td>DB_Loggerクラスのインスタンス</td>
        </tr>
        <tr>
            <td>$this-&gt;authCommon</td>
            <td>DB_AuthCommonクラスのインスタンス</td>
        </tr>
        <tr>
            <td>$this-&gt;formatter</td>
            <td>DB_Formattersクラスのインスタンス</td>
        </tr>
    </table>
</div>

<h2>ユーザ認証とアクセス権の動作について</h2>

<p>ユーザ認証とアクセス権の設定をサポートします。</p>


<p>
    ユーザ認証ではセキュリティを高めるために、サーバからクライアントに「チャレンジ」を送り、その値を利用して認証情報を作ります。そのため、サーバ側にチャレンジを残しておく必要があり、テーブルの定義が必要です。そのテーブルは、IM_Entryの第3引数あるいはparams.phpで指定したユーザで読み書きの権限が必要です。チャレンジのテーブル名は、IM_Entryの第2引数で指定するか、あるいは既定値の名前（issuedhash）のテーブルを作成します。テーブルには以下のフィールドが必要です。</p>


<div class="table">


    <div class="caption">チャレンジのテーブルに必要なフィールド</div>


    <table>


        <tr>
            <th>フィールド名</th>
            <th>型の例</th>
            <th>説明</th>
        </tr>


        <tr>
            <td>user_id</td>
            <td>INT,</td>
            <td>ユーザテーブルのキーフィールドとなるid値（ユーザをデータベース内のテーブルで管理する場合に利用）</td>
        </tr>


        <tr>
            <td>username</td>
            <td>VARCHAR(48),</td>
            <td>ユーザテーブルのキーフィールドとなるid値（ユーザをデータベースエンジンが提供するもので運用する場合に利用）</td>
        </tr>


        <tr>
            <td>clienthost</td>
            <td>VARCHAR(48),</td>
            <td>クライアントを識別するもの。Ver.1.0.5の実装では、クライアントのIPアドレスのみを記録している</td>
        </tr>


        <tr>
            <td>hash</td>
            <td>VARCHAR(48),</td>
            <td>チャレンジに使うハッシュ値。実際には24バイトの16進数文字列。</td>
        </tr>


        <tr>
            <td>expired</td>
            <td>DateTime,</td>
            <td>チャレンジの有効期限を示すタイムスタンプ値</td>
        </tr>


    </table>


</div>


<p>
    なお、このテーブルへの検索では、user_idとclienthostあるいはusernameとclienthostの2つのフィールドに対してAND演算での検索条件が与えられます。従って、高速化するためには、この2つのフィールドを合成したインデックスを作っておくなどの措置をとる事ができます。</p>


<p>
    認証のためのユーザは、データベース内にテーブルを作成する方法と、データベースエンジンが管理するユーザによる方法を利用できます。データベース内にテーブルを作る場合、そのテーブルは、IM_Entryの第3引数あるいはparams.phpで指定したユーザで少なくとも読み出しの権限が必要です。チャレンジのテーブル名は、IM_Entryの第2引数で指定するか、あるいは既定値の名前（authuser）のテーブルを作成します。テーブルには以下のフィールドが必要です。</p>


<div class="table">


    <div class="caption">ユーザテーブルに必要なフィールド</div>


    <table>


        <tr>
            <th>フィールド名</th>
            <th>型の例</th>
            <th>説明</th>
        </tr>


        <tr>
            <td>id</td>
            <td>INT AUTO_INCREMENT,</td>
            <td>連番の数値を入れて、キーフィールドとする</td>
        </tr>


        <tr>
            <td>username</td>
            <td>VARCHAR(48),</td>
            <td>ユーザ名（特に制限はないが、重複した名前が定義されないようにするのが望ましい）</td>
        </tr>


        <tr>
            <td>hashedpasswd</td>
            <td>VARCHAR(48),</td>
            <td>パスワードのハッシュ値</td>
        </tr>


    </table>


</div>


<p>
    ユーザの場合は、ユーザ名をキーフィールドに使えるとも考えられますが、大量のユーザになったときなどに処理速度を有利にするために、内部的には連番で与えた数値で処理をすることにします。なお、usernameを条件として検索をかけるので、高速化のためにはこのフィールドにインデックスを作成しておきます。パスワードはハッシュを保存しますが、ハッシュ値は、次の手順で計算をします。</p>


<ol>


    <li>パスワード（pw）と、4バイトのソルト（s）を用意します。</li>


    <li>パスワードとソルトをつなげた文字列のSHA-1を求めます（ sha1(pw+s) → H1）</li>


    <li>H1の16進数表現した文字列と、ソルトを16進数表現した文字列をつなげます（hex(H1)+hex(s)→H2）</li>


    <li>H2をフィールドに保存します。</li>


</ol>


<p>たとえば、Mac OS
    Xだと、pw=user1、s=TESTとすると、以下のコマンドで「d83eefa0a9bd7190c94e7911688503737a99db0154455354」というハッシュ値の16進数表現を求めることができます。</p>


<div class="code">
<pre>
<code>
pw=user1
salt=TEST
h1=`/bin/echo -n "${pw}${salt}" | openssl sha1 -sha1`
h2=`/bin/echo -n "${salt}" | xxd -ps`
echo ${h1}${h2}
</code>
</pre>
</div>


<div class="table">


    <div class="caption">グループテーブル（既定名：authgroup）のフィールド</div>


    <table>


        <tr>
            <th>フィールド名</th>
            <th>型の例</th>
            <th>説明</th>
        </tr>


        <tr>
            <td>id</td>
            <td>INT AUTO_INCREMENT,</td>
            <td>グループを識別するための番号</td>
        </tr>


        <tr>
            <td>groupname</td>
            <td>VARCHAR(48),</td>
            <td>グループ名</td>
        </tr>


    </table>


</div>


<div class="table">


    <div class="caption">ユーザ・グループ対応付けテーブル（既定名：authcor）のフィールド</div>


    <table>


        <tr>
            <th>フィールド名</th>
            <th>型の例</th>
            <th>説明</th>
        </tr>


        <tr>
            <td>user_id</td>
            <td>INT,</td>
            <td>所属するユーザのidフィールドの値</td>
        </tr>


        <tr>
            <td>group_id</td>
            <td>INT,</td>
            <td>所属するグループのidフィールドの値</td>
        </tr>


        <tr>
            <td>dest_group_id</td>
            <td>INT,</td>
            <td>所属されるグループのidフィールドの値</td>
        </tr>


    </table>


</div>


<h3>アクセス権に関する設定の評価</h3>


<p>
    認証の設定は基本的にコンテキストに行いますが、IM_Entryの2番目の引数にも行えます。つまり、2カ所の設定があるので、以下のように、コンテキストに設定する方を「コンテキストの認証設定」、2つ目の引数に設定するのを「オプションの認証設定」とします。また、いずれも、アクセス権の設定も行いますが、「認証とアクセス権」を合わせてここでは「認証」というネーミングをします。</p>


<div class="code">


   <pre><code>IM_Entry(

       array(
       array( "name"=>"context"

       "authentication"=>array(
       /* コンテキストの認証設定 */
       )
       )
       ),

       array(
       "authentication"=>array(
       /* オプションの認証設定 */
       ),
       ....);</code></pre>


</div>


<h4>コンテキストの認証設定なし、オプションの認証設定あり</h4>


<p>タイトル用な条件だと、コンテキストの認証設定のuserとgroupがアクセス権の設定に関係します。もし、userもgroupも設定されていない場合は、認証が通ったユーザは何でもできると考えてください。</p>


<p>userあるいはgroupが設定されている場合、認証が通ると同時に、そのユーザあるいはそのユーザを含むグループが、userあるいはgroupの設定に含まれている必要があります。</p>


<h4>コンテキストの認証設定あり、オプションの認証設定なし</h4>


<p>オプションの設定のうちuserとgroupの設定がないということです。この場合、特定のコンテキストのデータベース処理に対して、コンテキストの認証設定が適用されます。</p>


<h4>コンテキストの認証設定あり、オプションの認証設定あり</h4>


<p>両方の認証設定があれば、先にオプションの認証設定が評価されて、その後にコンテキストの認証設定が評価されます。</p>


<h4>コンテキストの認証設定の適用対象</h4>


<p>適用対象として、4つのデータベース処理、load/update/new/deleteに対する処理と、それらすべてに対してまとめて設定を行うallがあります。</p>


<h4>コンテキストの認証設定のtableとfleld</h4>


<p>
    "table"キーに対する値がfield-userあるいはfield-groupの場合は、そのテーブルにあるfieldに指定したフィールドに、ログインが成功したユーザあるいはそのユーザが含むグループの名前が設定されちているレコードだけに絞り込まれます。検索条件にANDでユーザないしはグループの値をfieldに指定したフィールドに対する条件を付け加えます。したがって、fieldで指定したフィールドのうち、空欄ものは認証すればいっさいアクセスできないということになります。</p>


<p>
    "table"キーに対する値がfield-useやfield-groupではない場合、アクセス権はすべてのテーブルに渡って適用されます。レコードごとのアクセス権を記録するフィールドは不要です。このとき、userあるいはgroup属性に含まれていないユーザで認証した場合、いっさいのアクセスはできないようになっています。オプションの認証設定と異なる動作ですので、注意してください。</p>


<p>
    load/update/deleteに関しては、アクセス権は「検索条件」として集約されます。一方、newの操作に対しては、アクセス権がある場合だけ、レコードの作成が可能です。レコードの作成により、fieldで指定したフィールドに、ユーザないしはグループが設定されます。ユーザの場合は1つに決まりますが、グループの場合は、グループ名を並べ替えたときのいちばん先頭のグループ名を記録するようにします。</p>

<h2>コンテキストの共有化とPusherの利用</h2>

<p>INTER-Mediatorでは、「コンテキスト」は、データベースに対するデータの出入り口的なイメージのものであり、検索条件などでの意味づけされたデータソースを意味します。その「共有化」とは、同一エンティティが複数のページ上のオブジェクトに展開されているとき、1つのエンティティを変更すると、その結果が他のオブジェクトにも反映される仕組みと定義します。Ver.4.4までに、単一ページ内のコンテキストの共有化が実現しています。つまり、あるページ上に、同一フィールドとバインドした要素があるとすると、一方を変更すると、もう一方は自動的に更新します。この動作を実現するためのプログラミングは必要なく、バインドの設定（ターゲット指定の付与）だけで可能です。</p>

<p>Ver.4.5に向けて、コンテキストの共有化をマルチクライアントで実現する仕組みを開発しており、概ね動くところまできました。つまり、同一のページを複数のクライアントで参照しているとき、誰かがデータを変更すると、その結果は他のユーザのページにも反映されるという動作が典型的です。従って、1つのフィールドを単一の要素にバインドしている場合でも、マルチユーザつまり複数のブラウザで同一のエンティティをバインドしているという点で「共有化」されていると言えるわけです。</p>

<p>コンテキストの共有化を実現するために、ページファイル上でのターゲット指定や、定義ファイルでのコンテキスト定義以外に何をしなければならないかをこの文書にまとめておきます。単一ページ内のコンテキストの共有化は特別な仕掛けは不要です。しかしながら、マルチクライアントでのコンテキストの共有化では、WebSocketを利用した<a href="http://pusher.com/" target="_blank">Pusher</a>というサービスを利用することにしました。試用程度なら無償ですが、実運用には有償となってしまうものの、開発の効率化のために利用することにしました。</p>

<h3>Pusherアカウントの取得とアプリケーション登録</h3>
<p><a href="http://pusher.com/" target="_blank">Pusher</a>のサイトでアカウントを取得します。Pusherでは「App」という単位で管理ができるので、たとえばINTER-Mediatorで作る1つのソリューションを、1つのPusherのAppとして登録するという方法もありますし、複数のソリューションで共有してもいいかもしれません。いずれにしても、アカウントを作成し、New Appというボタンなどで新たに1つのAppを作成します。ページ上に表示されるapp_id、key、secretの3つの情報がこの後に必要となります。</p>

<h3>Pusherのサーバプログラムのインストール</h3>
<p>PusherのサーバモジュールはPHP版を利用します。こちらのレポジトリをダウンロードし、そこから得られるlibディレクトリにあるPusher.phpという1つのファイルだけをサーバにインストールします。他は使用しません。ファイルはPHPの設定ファイル（php.iniが代表的）で、include_pathの設定で参照できるディレクトリにあればかまいません。もっとも安直な方法は、INTER-Mediatorフォルダに入れて、サーバにコピーしておくことです。もし、設定が以下のようなものであれば、例えば/usr/lib/phpディレクトリにPusher.phpをコピーしておけば良いでしょう。</p>
<div class="code"><pre><code>include_path = ".:/usr/lib/php/pear:/usr/lib/php"</code></pre></div>

<h3>ページファイルへの追加</h3>
<p>Pusherのクライアントソフトウエアを、ページファイルで組み込む必要があります。たとえば、以下のように、ヘッダ部で定義ファイル（include_MySQL.php）の読み込みの前に読み込みます。この方法だと、Pusherのサイトから直接取り出すので、ファイルを自分のサーバにコピーする必要はありません。ソースはこの通りコピペで大丈夫ですが、Pusherのバージョンが変わった時などはそれに合わせてください。</p>
<div class="code"><pre><code>&lt;html&gt;
&lt;head&gt;
    :
    <strong>&lt;script src="http://js.pusher.com/2.2/pusher.min.js" type="text/javascript"&gt;&lt;/script&gt;</strong>
    &lt;script type="text/javascript" src="include_MySQL.php"&gt;&lt;/script&gt;
&lt;/head&gt;</code></pre></div>

<h3>定義ファイルあるいはparams.phpへの追加</h3>
<p>Pusherで定義したAppに関する指定は、定義ファイルのオプション部あるいはparams.phpで指定をします。原則的にはどちらか一方で定義をしてください。両方指定すると、定義ファイルの方が優先されます。定義ファイルでは、pusherをキーにした配列を定義し、さらにPusherのAppで示された3つの値を配列の各要素の値とします。以下は、定義ファイルでの定義例です。</p>

<div class="code"><pre><code>IM_Entry(
    array(
　　　　　　　　　　　　　　/* コンテキストの定義 */
　　　　　　　),
    array(
        :
        'pusher' =&gt; array(
            'app_id' =&gt; '1234',
            'key' =&gt; '9876543210',
            'secret' =&gt; '9876543210',
        ),
    ),
    array('db-class' =&gt; 'PDO'),
    false
);</code></pre></div>

<p>params.phpファイルに記述するときには、以下のように、$pusherParameters変数に同様な配列として定義をします。</p>

<div class="code"><pre><code>$pusherParameters = array(
 'app_id' =&gt; '1234',
 'key' =&gt; '9876543210',
 'secret' =&gt; '9876543210',
);</code></pre></div>

<p>上記のいずれかがあると、マルチクライアントのコンテキストの共有化がオンになります。定義ファイルあるいはparams.phpの指定の有無だけで、共有化の利用／不使用が決まります。指定がないと一切何も行いません。指定があるのに、Pusherのサーバあるいはクライアントソフトウエアが利用できない状態になると、なんらかのエラーが発生します。</p>

<h3>現状での制約</h3>
<p>レコードの追加においては、そのコンテキストの検索条件を加味して、検索条件に合わないレコードの追加は行いません。しかしながら、別のクライアントで作成したレコードが当初はコンテキストに合わないものの、フィールドの値を変更してコンテキストの検索条件に合うようになっても、現状ではそのレコードが見えるようにはなりません。</p>

<p>さらに、コンテキストのソート条件は現状では加味されておらず、一連の表示リストのサイトに常に追加されます。</p>


</div>
</body>
</html>